configfile: "config/config_dict.yaml"

include: "rules/common.smk"

def all_builds(w):
    builds = []
    for lineage in config["builds"]:
        for segment in config["builds"][lineage]:
            for ref in config["builds"][lineage][segment]["refs"]:
                builds.append(f"datasets/{lineage}/{segment}/{ref}/tree.json")
                builds.append(f"build/{lineage}/{segment}/{ref}/founder_sequences.translations.done")
    return builds

rule all:
    input:
        all_builds


rule download_clades:
    message:
        "Downloading clade definitions for {wildcards.lineage} from {params.source_tsv} -> {output}"
    output:
        clade_tsv = "data/{lineage}/{segment}/{reference}/raw_{clade}.tsv"
    params:
        source_tsv = lambda w: (config['clade_repo'] if w.lineage!='yam' else '') + config["builds"][w.lineage][w.segment]["clade_systems"][w.clade]['url'],
    shell:
        """
        curl {params.source_tsv} > {output.clade_tsv}
        """

rule download_clade_tree:
    message:
        "Downloading clade tree for {wildcards.lineage} from {params.source_nwk} -> {output}"
    output:
        guide_tree = "data/{lineage}/{segment}/guide-tree_{clade}.nwk"
    params:
        source_nwk=lambda w: (config['clade_repo'] if w.lineage!='yam' else '') + config["builds"][w.lineage][w.segment]["clade_systems"][w.clade]['tree-url'],
    shell:
        """
        curl {params.source_nwk} > {output.guide_tree}
        """

rule download_changelog_clades:
    message:
        "Downloading nomenclature changelog for {wildcards.lineage} from {params.source} -> {output}"
    output:
        changelog = "data/{lineage}/{segment}/changelog.md"
    params:
        source=lambda w: config['clade_repo'] + config["builds"][w.lineage][w.segment]["changelog"],
    shell:
        """
        curl {params.source} > {output.changelog}
        """

rule offset_clades:
    input:
        rules.download_clades.output,
    output:
        "data/{lineage}/{segment}/{reference}/shifted_{clade}.tsv",
    params:
        offset=lambda w: config["builds"][w.lineage][w.segment]['refs'][w.reference][
            "clade_offset"
        ],
    shell:
        """
        perl -F'\\t' -ne \
            '$F[2]+={params.offset} if $F[1] =~ "nuc"; \
            print join "\\t", @F' \
            {input} \
            >{output}
        """

rule add_founders_to_alignment:
    input:
        alignment=rules.align.output.alignment,
        founder_sequences = "config/{lineage}/{segment}/{reference}/founder_sequences.fasta",
    output:
        alignment="build/{lineage}/{segment}/{reference}/align.aligned.with_founders.fasta"
    shell:
        """
        cat {input.alignment} {input.founder_sequences} > {output.alignment}
        """

def get_root_lineage(w):
    if "root_lineage" in config["builds"][w.lineage][w.segment]:
        return f" --root-lineage {config['builds'][w.lineage][w.segment]['root_lineage']}"
    else:
        return ""

def get_explicit_root(w):
    if "root" in config["builds"][w.lineage][w.segment]:
        return f" --explicit-root {config['builds'][w.lineage][w.segment]['root']}"
    else:
        return ""

rule tidytree:
    message: "Building tree"
    input:
        alignment = rules.add_founders_to_alignment.output.alignment,
        guide_tree = "data/{lineage}/{segment}/guide-tree_subclade.nwk",
        metadata = "data/{lineage}/{segment}/metadata.tsv",
    output:
        tree="build/{lineage}/{segment}/{reference}/tidytree.nwk"
    threads: 2
    params:
        clade_name = lambda w: 'subclade' if w.segment=='ha' else 'clade',
        explicit_root = get_explicit_root,
        root_lineage = get_root_lineage
    resources:
        mem_mb=16000,
        time="2:00:00",
    shell:
        """
        python3 ../scripts/tidy_tree.py \
            --alignment {input.alignment} \
            --guide-tree {input.guide_tree} \
            {params.root_lineage} \
            --lineage-assignments {input.metadata} \
            --seq-id-column strain \
            --lineage-column {params.clade_name} \
            --threads {threads} \
            --keep-founders \
            --iqtree-args '-ninit 10 -n 4 -czb' \
            --ignore-missing-founders \
            {params.explicit_root} \
            --output-tree {output.tree} 2>&1 | tee {log}
        """

rule sanitize:
    input:
        tree=rules.tidytree.output.tree,
    output:
        tree="build/{lineage}/{segment}/{reference}/tree_clean.nwk",
    params:
        prune_length = 0.03
    shell:
        """
        python scripts/root_and_sanitize.py \
            --input-tree {input.tree} \
            --prune-length {params.prune_length} \
            --output-tree {output.tree}
        """

# refine while keeping the root
rule refine:
    input:
        tree=rules.sanitize.output.tree,
        alignment=rules.add_founders_to_alignment.output.alignment,
        metadata="data/{lineage}/{segment}/metadata.tsv"
    output:
        tree="build/{lineage}/{segment}/{reference}/tree.nwk",
        node_data="build/{lineage}/{segment}/{reference}/branch_lengths.json",
    threads: 1
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --metadata {input.metadata} \
            --output-tree {output.tree} \
            --output-node-data {output.node_data} \
            --keep-root \
            --divergence-unit mutations-per-site
        """

rule ancestral:
    message:
        """
        Reconstructing ancestral sequences and mutations
          - inferring ambiguous mutations
        """
    input:
        tree=rules.refine.output.tree,
        alignment=rules.add_founders_to_alignment.output.alignment,
        annotation="dataset_config/{lineage}/{segment}/{reference}/annotation.gff",
        reference="dataset_config/{lineage}/{segment}/{reference}/reference.fasta",
    output:
        node_data="build/{lineage}/{segment}/{reference}/muts.json",
    params:
        inference="joint",
        genes=genes,
        translations= "build/{lineage}/{segment}/{reference}/aligned.gene.%GENE.fasta",
    shell:
        """
        augur ancestral \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --inference {params.inference} \
            --infer-ambiguous \
            --genes {params.genes} \
            --annotation {input.annotation} \
            --translations {params.translations:q} \
            --root-sequence {input.reference} \
            --output-node-data {output.node_data}
        """



rule clades:
    message:
        "Adding internal clade labels"
    input:
        tree=rules.refine.output.tree,
        muts=rules.ancestral.output.node_data,
        clades=rules.offset_clades.output,
    output:
        node_data="build/{lineage}/{segment}/{reference}/clade_{clade}.json",
    params:
        membership_key= lambda w: config["builds"][w.lineage][w.segment]["clade_systems"][w.clade].get('key', 'clade_membership'),
        label_key= lambda w: config["builds"][w.lineage][w.segment]["clade_systems"][w.clade].get('key', 'clade')
    shell:
        """
        augur clades --tree {input.tree} \
            --mutations {input.muts} \
            --clades {input.clades} \
            --membership-name {params.membership_key} \
            --label-name {params.label_key} \
            --output-node-data {output.node_data} \
        """

rule adjust_branch_lengths:
    message:
        "Adjusting branch lengths for visualization"
    input:
        branch_lengths=rules.refine.output.node_data,
        clades="build/{lineage}/{segment}/{reference}/clade_subclade.json"
    output:
        branch_lengths="build/{lineage}/{segment}/{reference}/branch_lengths_adjusted.json",
    params:
        max_length = lambda w: config["builds"][w.lineage][w.segment].get('max_branch_length', 0.0),
    shell:
        """
        python scripts/adjust_branch_lengths.py \
            --branch-lengths {input.branch_lengths} \
            --clade-json {input.clades} \
            --max-branch-length {params.max_length} \
            --output-node-data {output.branch_lengths}
        """


def get_node_data(w):
    node_data = [
        rules.adjust_branch_lengths.output.branch_lengths,
        "build/{lineage}/{segment}/{reference}/muts.json".format(**w),
    ]

    for clade in config["builds"][w.lineage][w.segment]["clade_systems"]:
        node_data.append("build/{lineage}/{segment}/{reference}/".format(**w) + f'clade_{clade}.json')

    return node_data



rule export:
    message:
        "Exporting data files for auspice"
    input:
        tree="build/{lineage}/{segment}/{reference}/tree.nwk",
        metadata="data/{lineage}/{segment}/metadata.tsv",
        node_data = get_node_data,
        auspice_config= "build/{lineage}/{segment}/{reference}/auspice_config.json"
    output:
        auspice_json="build/{lineage}/{segment}/{reference}/auspice.json",
    params:
        fields="strain region country date gisaid_epi_isl accession_{segment}",
        select_fields = ','.join(["strain", "region", "country", "date", "gisaid_epi_isl", "accession_{segment}"]),
        date=datetime.datetime.utcnow().strftime("%Y-%m-%d"),
    shell:
        """
        tsv-select -H -f {params.select_fields} {input.metadata} > {input.metadata}.tmp
        augur export v2 \
            --tree {input.tree} \
            --metadata {input.metadata}.tmp \
            --node-data {input.node_data}\
            --auspice-config {input.auspice_config} \
            --color-by-metadata {params.fields} \
            --include-root-sequence-inline \
            --minify-json \
            --skip-validation \
            --title "Nextclade reference tree for Influenza type:{wildcards.lineage} segment:{wildcards.segment} with root {wildcards.reference} built on {params.date}" \
            --output {output.auspice_json} 2>&1;
        """


rule extract_clade_founders:
    input:
        clades="build/{lineage}/{segment}/{reference}/clade_subclade.json",
        ancestral = "build/{lineage}/{segment}/{reference}/muts.json",
    output:
        sequences="config/{lineage}/{segment}/{reference}/founder_sequences_new.fasta",
    shell:
        """
        python3 scripts/extract_founder_sequences.py \
            --clades-json {input.clades} \
            --ancestral-json {input.ancestral} \
            --output {output.sequences}
        """

rule translate_clade_founders:
    input:
        sequences=rules.extract_clade_founders.output.sequences,
        annotation="dataset_config/{lineage}/{segment}/{reference}/annotation.gff",
        reference="dataset_config/{lineage}/{segment}/{reference}/reference.fasta",
    output:
        translations="build/{lineage}/{segment}/{reference}/founder_sequences.translations.done",
    params:
        outdir=lambda w: f"config/{w.lineage}/{w.segment}/{w.reference}/founder_sequences_new_{{cds}}.fasta",
        nextclade_bin = "nextclade3"
    threads: 3
    shell:
        """
        {params.nextclade_bin} run \
            --jobs={threads} \
            --input-ref {input.reference} \
            --input-annotation {input.annotation} \
            --gap-alignment-side right \
            --in-order \
            --output-translations {params.outdir} \
            {input.sequences}
        touch {output.translations}
        """



rule make_dataset:
    input:
        sequences="build/{lineage}/{segment}/{reference}/sample_sequences.fasta",
        auspice_json="build/{lineage}/{segment}/{reference}/auspice.json",
        annotation="dataset_config/{lineage}/{segment}/{reference}/annotation.gff",
        reference="dataset_config/{lineage}/{segment}/{reference}/reference.fasta",
        readme="dataset_config/{lineage}/{segment}/{reference}/README.md",
        dataset_changelog="data/{lineage}/{segment}/{reference}/dataset-changelog.md",
        pathogen_json="build/{lineage}/{segment}/{reference}/pathogen.json",
    output:
        sequences="datasets/{lineage}/{segment}/{reference}/sequences.fasta",
        tree="datasets/{lineage}/{segment}/{reference}/tree.json",
        annotation="datasets/{lineage}/{segment}/{reference}/genome_annotation.gff3",
        reference="datasets/{lineage}/{segment}/{reference}/reference.fasta",
        readme="datasets/{lineage}/{segment}/{reference}/README.md",
        pathogen_json="datasets/{lineage}/{segment}/{reference}/pathogen.json",
        auspice="auspice/{lineage}_{segment}_{reference}.json",
        changelog="datasets/{lineage}/{segment}/{reference}/CHANGELOG.md",
    shell:
        """
        cp {input.sequences} {output.sequences}
        cp {input.auspice_json} {output.tree}
        cp {input.reference} {output.reference}
        cp {input.readme} {output.readme}
        cp {input.dataset_changelog} {output.changelog}
        cp {input.annotation} {output.annotation}
        cp {input.pathogen_json} {output.pathogen_json}
        cp {input.auspice_json} {output.auspice}
        """


rule clean:
    shell:
        """
        rm -rf build datasets auspice
        """


rule clean_all:
    shell:
        """
        rm -rf build
        rm -rf auspice
        rm -rf datasets
        rm -rf data/
        """
