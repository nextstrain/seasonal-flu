#!/usr/bin/env python3
"""
Links the records in the downloaded files from GISAID EpiFlu.
Excel metadata records are linked with segment sequences in the FASTA and
output as NDJSON to stdout.

Each record represents a single GISAID record, formatted as:

    {
        “Isolate_Id”: “...”,
        “Isolate_Name”: “...”,
        “Collection_Date”: “...”,
        “Passage_History”: “...”,
        […other metadata fields…],
        “sequences”: {
            "ha": [
                {
                    “accession”: “...”,
                    “sequence”: “...”
                },
                {
                    “accession”: “...”,
                    “sequence”: “...”
                }
            ],
            "na": [
                {
                    "accession": "...",
                    "sequence": "..."
                }
            ],
            […other 8 segments…]
        }
    }

Segments without any sequences will be represented as an empty list.
"""
import argparse
import os
import pyfastx
import re
from collections import defaultdict
from textwrap import dedent
from typing import Iterable, Optional
from augur.io.json import dump_ndjson
from augur.io.metadata import DEFAULT_DELIMITERS, read_table_to_dict
from augur.io.print import print_err


# Expected segments from GISAID EpiFlu
# The last two segments (HE and P3) are unused, but keeping for completion
#   -Jover, 11 February 2025
SEGMENTS = [
    "pb2",
    "pb1",
    "pa",
    "ha",
    "np",
    "na",
    "mp",
    "ns",
    "he",
    "p3",
]

SEGMENT_ACCESSION_PATTERN = r'^\s*(?P<accession>EPI\d+)\|'

# Expected columns in the GISAID xls file
# Hard-coding here as I don't expect them to change, but if they get updated
# often enough then we can consider making them CLI options.
#   -Jover, 11 February 2025
RECORD_ID_COLUMN = "Isolate_Id"
SEGMENT_COLUMNS = {
    segment: f"{segment.upper()} Segment_Id"
    for segment in SEGMENTS
}
ADDITIONAL_METADATA_COLUMNS = {
    "Isolate_Name",
    "Subtype",
    "Genotype",
    "Lineage",
    "Clade",
    "Pathogenicity",
    "Passage_History",
    "Location",
    "Host",
    "Isolate_Submitter",
    "Submitting_Lab",
    "Submitting_Sample_Id",
    "Authors",
    "Publication",
    "Originating_Lab",
    "Originating_Sample_Id",
    "Collection_Date",
    "Note",
    "Update_Date",
    "Submission_Date",
    "Antigen_Character",
    "Animal_Vaccin_Product",
    "Adamantanes_Resistance_geno",
    "Oseltamivir_Resistance_geno",
    "Zanamivir_Resistance_geno",
    "Peramivir_Resistance_geno",
    "Other_Resistance_geno",
    "Adamantanes_Resistance_pheno",
    "Oseltamivir_Resistance_pheno",
    "Zanamivir_Resistance_pheno",
    "Peramivir_Resistance_pheno",
    "Other_Resistance_pheno",
    "Host_Age",
    "Host_Age_Unit",
    "Host_Gender",
    "Patient_Status",
    "Zip_Code",
    "Outbreak",
    "Pathogen_Test_Info",
    "Is_Vaccinated",
    "Human_Specimen_Source",
    "Animal_Specimen_Source",
    "Animal_Health_Status",
    "Domestic_Status",
    "PMID",
}
OUTPUT_SEQUENCE_FIELD = "sequences"
ALL_EXPECTED_FIELDS = set([RECORD_ID_COLUMN, OUTPUT_SEQUENCE_FIELD]).union(ADDITIONAL_METADATA_COLUMNS)


def link_metadata_and_sequences(metadata: Iterable[dict],
                                sequences: pyfastx.Fasta) -> Iterable[dict]:
    """
    Link records in the provided *metadata* with segment sequences in the
    provided *sequences*. Drops the segment fields and adds a "sequences"
    field, which is an array of all of the segments.
    """
    records_without_accessions = 0
    records_without_sequences = 0
    total_records = 0
    missing_fields = set()
    unexpected_fields = set()
    for record in metadata:
        linked_record = record.copy()
        record_id = linked_record[RECORD_ID_COLUMN]

        # Verify that all the expected segment columns are present in
        # the first record since all records should have the same columns
        if total_records == 0:
            assert all(
                column in linked_record
                for column in SEGMENT_COLUMNS.values()), \
                f"The metadata does not include all expected segment columns: {SEGMENT_COLUMNS.values()!r}.\n" + \
                "The expected `SEGMENTS` or `SEGMENT_COLUMNS` might need to be updated."

        record_seqs = {}
        unmatched_accessions = defaultdict(list)
        unmatched_sequences = defaultdict(list)
        for segment, segment_column in SEGMENT_COLUMNS.items():
            record_seqs[segment] = []
            if segment_ids := linked_record.pop(segment_column):
                for segment_id in segment_ids.split(","):
                    if accession := parse_segment_accession(segment_id):
                        if sequence := get_segment_sequence(sequences, accession):
                            record_seqs[segment].append({
                                "accession": accession,
                                "sequence": sequence
                            })
                        else:
                            unmatched_sequences[segment].append(accession)
                    else:
                        unmatched_accessions[segment].append(segment_id)

        if len(unmatched_accessions):
            print_err(
                "WARNING: Could not match segment accessions for record",
                f"{record_id!r} for the following segments: {unmatched_accessions!r}"
            )
            records_without_accessions += 1

        if len(unmatched_sequences):
            print_err(
                f"WARNING: Could not find sequences for record {record_id!r}",
                f"for the following segment accessions: {unmatched_sequences}"
            )
            records_without_sequences += 1

        linked_record[OUTPUT_SEQUENCE_FIELD] = record_seqs

        # Remove extra fields that are not expected
        for field in list(linked_record.keys()):
            if field not in ALL_EXPECTED_FIELDS:
                unexpected_fields.add(field)
                del linked_record[field]
                 
        # Fill in empty values for additional metadata columns
        for column in ADDITIONAL_METADATA_COLUMNS:
            if linked_record.get(column) is None:
                missing_fields.add(column)
                linked_record[column] = ""

        total_records += 1
        yield linked_record

    assert total_records != records_without_accessions, \
        "All records are missing segment accessions.\n" + \
        "The `SEGMENT_ACCESSION_PATTERN` for matching accessions might need to be updated."

    assert total_records != records_without_sequences, \
        "All records are missing segment sequences.\n" + \
        "Verify the provided GISAID Excel file and FASTA file contain the same records."

    if missing_fields:
        print_err(f"WARNING: Metadata was missing columns {missing_fields!r}.",
                  "The fields have been added with empty string values.")

    if unexpected_fields:
        print_err(f"WARNING: Metadata had new columns {unexpected_fields!r}.",
                  "These fields have been removed from the record.")


def parse_segment_accession(segment_id: str) -> Optional[str]:
    """
    Parses the segment accession from the provided *segment_id*. If unable to
    parse the accession, then returns None.
    """
    accession = None

    matches = re.search(SEGMENT_ACCESSION_PATTERN, segment_id)
    if matches is not None:
        accession = matches["accession"]

    return accession


def get_segment_sequence(sequences: pyfastx.Fasta, accession: str) -> Optional[str]:
    """
    Gets the sequence matching the provided *accession* from the indexed
    *sequences. If there is not matching sequence, returns None.
    """
    sequence = None

    # try/except was consistently faster than checking accession is in sequences
    #   -Jover, 11 February 2025
    try:
        sequence_record = sequences[accession]
    except KeyError:
        pass
    else:
        sequence = str(sequence_record.seq).upper()

    return sequence


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument("--metadata", metavar="<xls>",
        help=dedent(f"""\
            GISAID EpiFlu metadata xls file, which is expected to have the
            record id column {RECORD_ID_COLUMN!r} and the segment ID columns
            {[SEGMENT_COLUMNS.values()]!r}. Each segment ID column is expected
            to contain segment IDs with the segment accession matching
            {SEGMENT_ACCESSION_PATTERN}.
            """))

    parser.add_argument("--sequences", metavar="<fasta>",
        help=dedent(f"""\
            GISAID EpiFlu FASTA file, where the headers should only be the
            sequence accession. This is the “DNA Accession no.” field in the
            GISAID "Sequences (DNA) as FASTA" download options.
            """))

    args = parser.parse_args()

    metadata = read_table_to_dict(
        table=args.metadata,
        delimiters=DEFAULT_DELIMITERS,
        id_column=RECORD_ID_COLUMN
    )

    # Remove the old Pyfastx index to force rebuild of index
    # so we don't have to worry about a stale cached index
    #   -Jover, 11 February 2025
    try:
        os.remove(f"{args.sequences}.fxi")
    except FileNotFoundError:
        pass

    sequences = pyfastx.Fasta(args.sequences)
    linked_records = link_metadata_and_sequences(metadata, sequences)
    dump_ndjson(linked_records)

    # Remove Pyfastx index to save disk space
    os.remove(f"{args.sequences}.fxi")
