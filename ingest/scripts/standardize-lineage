#!/usr/bin/env python3
"""
Standardize lineage based on GISAID's subtype and lineage.
"""
import argparse
import re
import csv
from sys import stdin
from typing import Iterable, Dict
from augur.io.json import dump_ndjson, load_ndjson
from augur.io.print import print_err


# GISAID lineage patterns copied from nextstrain/fauna/vdb/flu_upload.py
# <https://github.com/nextstrain/fauna/blob/fbdc393581b1859ac817403d8f43e114d7edbc60/vdb/flu_upload.py#L22-L44>
# Maps GISAID "Subtype" and "Lineage" fields to the standardized type, subtype, and lineage.
# type    = virus type (i.e. A or B)
# subtype = HxNx subtype
# lineage = standardized lineages used in our builds
GISAID_LINEAGE_MAP = {
#   (GISAID Subtype,  GISAID Lineage):    (type,   subtype,   lineage)
    ('a',             ''):                ('a',    'n/a',     'n/a'),
    ('a / h1n1',      'pdm09'):           ('a',    'h1n1',    'h1n1pdm'),
    ('a / h1n2',      ''):                ('a',    'h1n2',    'n/a'),
    ('a / h1n2',      'seasonal'):        ('a',    'h1n2',    'h1n2'),
    ('a / h2n2',      ''):                ('a',    'h2n2',    'n/a'),
    ('a / h3n2',      ''):                ('a',    'h3n2',    'h3n2'),
    ('a / h3n2',      'seasonal'):        ('a',    'h3n2',    'h3n2'),
    ('a / h3n3',      ''):                ('a',    'h3n3',    'n/a'),
    ('a / h5n1',      ''):                ('a',    'h5n1',    'n/a'),
    ('a / h5n6',      ''):                ('a',    'h5n6',    'n/a'),
    ('a / h6n1',      ''):                ('a',    'h6n1',    'n/a'),
    ('a / h7n1',      ''):                ('a',    'h7n1',    'n/a'),
    ('a / h7n2',      ''):                ('a',    'h7n2',    'n/a'),
    ('a / h7n3',      ''):                ('a',    'h7n3',    'n/a'),
    ('a / h7n7',      ''):                ('a',    'h7n7',    'n/a'),
    ('a / h7n9',      ''):                ('a',    'h7n9',    'n/a'),
    ('a / h9n2',      ''):                ('a',    'h9n2',    'n/a'),
    ('a / h10n7',     ''):                ('a',    'h10n7',   'n/a'),
    ('a / h10n8',     ''):                ('a',    'h10n8',   'n/a'),
    ('a / h11',       ''):                ('a',    'h11',     'n/a'),
    ('b',             ''):                ('b',    'n/a',     'n/a'),
    ('b / h0n0',      'victoria'):        ('b',    'n/a',     'vic'),
    ('b / h0n0',      'yamagata'):        ('b',    'n/a',     'yam'),
    ('b',             'victoria'):        ('b',    'n/a',     'vic'),
    ('b',             'yamagata'):        ('b',    'n/a',     'yam'),
}

TBD_TYPE = "tbd"
UNKNOWN_SUBTYPE = "n/a"

def standardize_record_lineage(records: Iterable[dict],
                               subtype_field: str,
                               lineage_field: str,
                               note_field: str,
                               new_type_field: str,
                               new_subtype_field: str,
                               new_lineage_field: str,
                               annotations_field: str,
                               annotations: Dict[str, Dict[str,str]]) -> Iterable:
    """
    Match the GISAID *subtype_field* and *lineage_field* to the
    GISAID_LINEAGE_MAP to add standardized fields for type, subtype, and
    lineage to the *records*.

    Yields the modified records.

    Based on nextstrain/fauna/vdb/flu_upload.py
    <https://github.com/nextstrain/fauna/blob/fbdc393581b1859ac817403d8f43e114d7edbc60/vdb/flu_upload.py#L462-L484>
    """
    unknown_gisaid_types = set()
    for record in records:
        gisaid_subtype = record.get(subtype_field)
        gisaid_lineage = record.get(lineage_field)
        gisaid_note = record.get(note_field)
        annotations_key = record.get(annotations_field, None) if annotations else ''

        if gisaid_subtype is None:
            raise Exception(f"Records must have the expected GISAID subtype field: {subtype_field!r}")

        if gisaid_lineage is None:
            raise Exception(f"Records must have the expected GISAID lineage field: {lineage_field!r}")

        if annotations_key is None:
            raise Exception(f"Records must have the annotations field {annotations_field!r} if an annotations TSV is being used")


        if not gisaid_lineage.strip() and gisaid_note:
            gisaid_lineage = parse_lineage_from_note(gisaid_note)

        gisaid_types = (gisaid_subtype.lower(), gisaid_lineage.lower())
        lineage_match = GISAID_LINEAGE_MAP.get(gisaid_types)

        # Records without clear subtype/lineage are marked as "tbd"
        # e.g. sequences submitted with _only_ the HA segment
        if lineage_match is None:
            unknown_gisaid_types.add(gisaid_types)
            lineage_match = (TBD_TYPE, TBD_TYPE, TBD_TYPE)

        record[new_type_field]    = lineage_match[0]
        record[new_subtype_field] = lineage_match[1]
        record[new_lineage_field] = lineage_match[2]

        # Apply hardcoded annotations last as they override everything        
        if hardcoded:=annotations.get(annotations_key):
            changes = False
            if record[new_type_field]!=hardcoded['type']:
                record[new_type_field] = hardcoded['type']
                changes=True
            if record[new_subtype_field]!=hardcoded['subtype']:
                record[new_subtype_field] = hardcoded['subtype']
                changes=True
            if record[new_lineage_field]!=hardcoded['lineage']:
                record[new_lineage_field] = hardcoded['lineage']
                changes=True
            if not changes:
                print_err(f"Lineage annotation for {annotations_key!r} is unnecessary (no changes needed)")

        yield record

    if len(unknown_gisaid_types):
        print_err(
            "WARNING: Records with the following GISAID subtype and lineages",
            f"were marked as {TBD_TYPE!r}: {unknown_gisaid_types!r}"
        )


def parse_lineage_from_note(note: str) -> str:
    """
    Parse known patterns in the *note* value that are used to annotate lineages.

    If the *note* matches a pattern, then returns the expected lineage from GISAID,
    i.e. the key in the `GISAID_LINEAGE_MAP`.
    """
    note = note.strip()
    H1N1PDM_PATTERNS = re.compile(r"^H1N1pdm09$|lineage: A\(H1N1\)pdm09|Influenza A\(H1N1\) pandemic", re.IGNORECASE)
    VIC_PATTERNS = re.compile(r"^Victoria$|B/Vic|type: Vic|Victoria lineage|lineage: Victoria", re.IGNORECASE)
    YAM_PATTERNS = re.compile(r"^Yamagata$|B/Yam|type: Yam|Yamagata lineage|lineage: Yamagata", re.IGNORECASE)

    if re.match(H1N1PDM_PATTERNS, note):
        return "pdm09"

    if re.match(VIC_PATTERNS, note):
        return "victoria"

    if re.match(YAM_PATTERNS, note):
        return "yamagata"

    return ""

def read_annotations_tsv(fname):
    # Based on augur curate's apply_record_annotations.py
    # <https://github.com/nextstrain/augur/blob/58f8b1aea1c135f71796bc9fbd8fefe6bc9e4369/augur/curate/apply_record_annotations.py#L31C1-L41C70>
    annotations = {}
    with open(fname, 'r', newline='') as annotations_fh:
        csv_reader = csv.reader(annotations_fh, delimiter='\t')
        for row in csv_reader:
            if not row or row[0].lstrip()[0] == '#':
                    continue
            elif len(row) != 2:
                print_err("WARNING: Could not decode lineage annotation TSV line " + "\t".join(row))
                continue
            isl, data = row
            # data format is type:subtype:lineage
            parts = data.split('#')[0].rstrip().split('/')
            if len(parts)!=3:
                print_err("WARNING: Could not decode lineage annotation TSV line - ensure type/subtype/lineage formatting is correct. " + "\t".join(row))
                continue
            if isl in annotations:
                print_err(f"ISL {isl} already seen in annotations TSV. Overwriting.")
            annotations[isl] = {
                'type': parts[0],
                'subtype': parts[1] if parts[1] else UNKNOWN_SUBTYPE,
                'lineage': parts[2],
            }
    return annotations

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument("--subtype-field", default="Subtype",
        help="The record field containing the GISAID subtype")
    parser.add_argument("--lineage-field", default="Lineage",
        help="The record field containing the GISAID lineage")
    parser.add_argument("--note-field", default="Note",
        help="The record field containing free text note that could be the lineage")
    parser.add_argument("--new-type-field", default="vtype",
        help="The name of the new field to add to the record with the type, " + \
             f"e.g. a or b. If type is undetermined, will default to {TBD_TYPE!r}")
    parser.add_argument("--new-subtype-field", default="subtype",
        help="The name of the new field to add to the record with the subtype, " + \
             f"e.g. h1n1. If subtype is unknown, will default to {TBD_TYPE!r}")
    parser.add_argument("--new-lineage-field", default="lineage",
        help="The name of the new field to add to the record with the lineage, " + \
             f"e.g. h1n1pdm. If subtype is unknown, will default to {TBD_TYPE!r}")
    parser.add_argument("--annotations", metavar="TSV", 
        help="Manually curated annotations TSV file. " +
             "The TSV should have two columns, the first is the EPI ISL and " +
             "the second defines the <type>:<subtype>:<lineage>. " +
             "Lines starting with '#' are treated as comments. " +
             "Any '#' after the field value are treated as comments.")
    parser.add_argument("--annotations-field", default="gisaid_epi_isl",
        help="The record field used match against the annotations TSV")
    args = parser.parse_args()

    annotations = read_annotations_tsv(args.annotations) if args.annotations else {}

    records = load_ndjson(stdin)
    modified_records = standardize_record_lineage(
        records,
        args.subtype_field,
        args.lineage_field,
        args.note_field,
        args.new_type_field,
        args.new_subtype_field,
        args.new_lineage_field,
        args.annotations_field,
        annotations)
    dump_ndjson(modified_records)
