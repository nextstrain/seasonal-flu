#!/usr/bin/env python3
"""
Standardize lineage based on GISAID's subtype and lineage.
"""
import argparse
import re
import csv
from pathlib import Path
import sys
from typing import Iterable, Dict
from augur.io.json import dump_ndjson, load_ndjson

SCRIPT_NAME = Path(sys.argv[0]).stem

def print_err(*args):
    print(f"[{SCRIPT_NAME}] ", *args, file=sys.stderr)

UNKNOWN = "n/a" # value to use for unknown subtypes / lineages

# Maps GISAID "Subtype" and "Lineage" fields to the standardized type, subtype, and lineage.
# (matching will be performed case-insensitive). To summarise the underlying data you can run:
# `cat data/gisaid.ndjson | jq -r '[.Subtype, .Lineage] | join(" :: ")' | sort  | uniq -c | sort -h`
#
# Originally copied from nextstrain/fauna/vdb/flu_upload.py <https://github.com/nextstrain/fauna/blob/fbdc393581b1859ac817403d8f43e114d7edbc60/vdb/flu_upload.py#L22-L44>
# and edited to incorporate all known HA / NA subtypes. The gisaid lineage "seasonal" is ignored
# as we don't use this to differentiate isolates in our pipeline. It's unclear why we first copied
# (A) subtypes to the lineage field, but that's become the norm so it's preserved here.
#
# type    = virus type (i.e. A or B)
# subtype = A viruses only -- "HxNx" subtype, or "Hx" or "Nx" if full genome not sequenced
# lineage = standardized lineages used in our builds
GISAID_LINEAGE_MAP = {
#   (GISAID Subtype,  GISAID Lineage):    (type,   subtype,   lineage)
    # A-Type viruses
    ('a',             ''):                ('a',    UNKNOWN,     UNKNOWN),
    # The only gisaid lineage other than "seasonal" is "pdm09"
    ('a / h1n1',      'pdm09'):           ('a',    'h1n1',    'h1n1pdm'),
    # Add all (A) HA / NA combinations
    **{(f"a / h{HA_NUM}n{NA_NUM}", ''):   ('a',    f"h{HA_NUM}n{NA_NUM}",  f"h{HA_NUM}n{NA_NUM}") for HA_NUM in range(1, 19+1) for NA_NUM in range(1, 11+1)},
    # and all (A) HA-only combinations (presumably as the NA wasn't sequenced?)
    **{(f"a / h{HA_NUM}", ''):            ('a',    f"h{HA_NUM}",           f"h{HA_NUM}")          for HA_NUM in range(1, 19+1)},
    # and vice-versa, presumably when the HA wasn't sequenced!
    **{(f"a / n{NA_NUM}", ''):            ('a',    f"n{NA_NUM}",           f"n{NA_NUM}")          for NA_NUM in range(1, 11+1)},
    # B-Type viruses
    ('b',             ''):                ('b',    UNKNOWN,     UNKNOWN),
    ('b',             'victoria'):        ('b',    UNKNOWN,     'vic'),
    ('b',             'yamagata'):        ('b',    UNKNOWN,     'yam'),
    # C-Type viruses (n=727 as of November 2025)
    ('c',             ''):                ('c',    UNKNOWN,     UNKNOWN),
}

TBD_TYPE = "tbd"

def standardize_record_lineage(records: Iterable[dict],
                               subtype_field: str,
                               lineage_field: str,
                               note_field: str,
                               new_type_field: str,
                               new_subtype_field: str,
                               new_lineage_field: str,
                               annotations_field: str,
                               annotations: Dict[str, Dict[str,str]]) -> Iterable:
    """
    Match the GISAID *subtype_field* and *lineage_field* to the
    GISAID_LINEAGE_MAP to add standardized fields for type, subtype, and
    lineage to the *records*.

    Yields the modified records.

    Based on nextstrain/fauna/vdb/flu_upload.py
    <https://github.com/nextstrain/fauna/blob/fbdc393581b1859ac817403d8f43e114d7edbc60/vdb/flu_upload.py#L462-L484>
    """
    num_records_unmatched = 0
    for record in records:
        gisaid_subtype = record.get(subtype_field)
        gisaid_lineage = record.get(lineage_field)

        # ignore "seasonal" lineage info as we don't use it (see earlier comment)
        if gisaid_lineage == 'seasonal':
            gisaid_lineage = ''

        gisaid_note = record.get(note_field)
        annotations_key = record.get(annotations_field, None) if annotations else ''

        if gisaid_subtype is None:
            raise Exception(f"Records must have the expected GISAID subtype field: {subtype_field!r}")

        if gisaid_lineage is None:
            raise Exception(f"Records must have the expected GISAID lineage field: {lineage_field!r}")

        if annotations_key is None:
            raise Exception(f"Records must have the annotations field {annotations_field!r} if an annotations TSV is being used")


        if not gisaid_lineage.strip() and gisaid_note:
            gisaid_lineage = parse_lineage_from_note(gisaid_note)

        gisaid_types = (gisaid_subtype.lower(), gisaid_lineage.lower())
        lineage_match = GISAID_LINEAGE_MAP.get(gisaid_types)

        record[new_type_field]    = lineage_match[0] if lineage_match else TBD_TYPE
        record[new_subtype_field] = lineage_match[1] if lineage_match else TBD_TYPE
        record[new_lineage_field] = lineage_match[2] if lineage_match else TBD_TYPE

        # Apply hardcoded annotations last as they override everything. Doing so last
        # allows us to print warnings when the annotation was unnecessary
        if hardcoded:=annotations.get(annotations_key):
            changes = False
            if record[new_type_field]!=hardcoded['type']:
                record[new_type_field] = hardcoded['type']
                changes=True
            if record[new_subtype_field]!=hardcoded['subtype']:
                record[new_subtype_field] = hardcoded['subtype']
                changes=True
            if record[new_lineage_field]!=hardcoded['lineage']:
                record[new_lineage_field] = hardcoded['lineage']
                changes=True
            if not changes:
                print_err(f"Lineage annotation for {annotations_key!r} is unnecessary (no changes needed)")

        elif not lineage_match:
            print_err(f"no lineage match for {record['gisaid_epi_isl']} {record['gisaid_strain']!r}. Subtype: {gisaid_subtype!r} lineage {gisaid_lineage!r}")
            num_records_unmatched+=1

        yield record

    if num_records_unmatched:
        print_err(f"In total {num_records_unmatched:,} records were not matched against our set of known types/subtypes/lineages (see previous messages)")


def parse_lineage_from_note(note: str) -> str:
    """
    Parse known patterns in the *note* value that are used to annotate lineages.

    If the *note* matches a pattern, then returns the expected lineage from GISAID,
    i.e. the key in the `GISAID_LINEAGE_MAP`.
    """
    note = note.strip()
    H1N1PDM_PATTERNS = re.compile(r"^H1N1pdm09$|lineage: A\(H1N1\)pdm09|Influenza A\(H1N1\) pandemic", re.IGNORECASE)
    VIC_PATTERNS = re.compile(r"^Victoria$|B/Vic|type: Vic|Victoria lineage|lineage: Victoria", re.IGNORECASE)
    YAM_PATTERNS = re.compile(r"^Yamagata$|B/Yam|type: Yam|Yamagata lineage|lineage: Yamagata", re.IGNORECASE)

    if re.match(H1N1PDM_PATTERNS, note):
        return "pdm09"

    if re.match(VIC_PATTERNS, note):
        return "victoria"

    if re.match(YAM_PATTERNS, note):
        return "yamagata"

    return ""

def read_annotations_tsv(fname):
    # Based on augur curate's apply_record_annotations.py
    # <https://github.com/nextstrain/augur/blob/58f8b1aea1c135f71796bc9fbd8fefe6bc9e4369/augur/curate/apply_record_annotations.py#L31C1-L41C70>
    annotations = {}
    with open(fname, 'r', newline='') as annotations_fh:
        csv_reader = csv.reader(annotations_fh, delimiter='\t')
        for row in csv_reader:
            if not row or row[0].lstrip()[0] == '#':
                    continue
            elif len(row) != 2:
                print_err("WARNING: Could not decode lineage annotation TSV line " + "\t".join(row))
                continue
            isl, data = row
            # data format is type:subtype:lineage
            parts = data.split('#')[0].rstrip().split('/')
            if len(parts)!=3:
                print_err("WARNING: Could not decode lineage annotation TSV line - ensure type/subtype/lineage formatting is correct. " + "\t".join(row))
                continue
            if isl in annotations:
                print_err(f"ISL {isl} already seen in annotations TSV. Overwriting.")
            annotations[isl] = {
                'type': parts[0],
                'subtype': parts[1] if parts[1] else UNKNOWN,
                'lineage': parts[2],
            }
    return annotations

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument("--subtype-field", default="Subtype",
        help="The record field containing the GISAID subtype")
    parser.add_argument("--lineage-field", default="Lineage",
        help="The record field containing the GISAID lineage")
    parser.add_argument("--note-field", default="Note",
        help="The record field containing free text note that could be the lineage")
    parser.add_argument("--new-type-field", default="vtype",
        help="The name of the new field to add to the record with the type, " + \
             f"e.g. a or b. If type is undetermined, will default to {TBD_TYPE!r}")
    parser.add_argument("--new-subtype-field", default="subtype",
        help="The name of the new field to add to the record with the subtype, " + \
             f"e.g. h1n1. If subtype is unknown, will default to {TBD_TYPE!r}")
    parser.add_argument("--new-lineage-field", default="lineage",
        help="The name of the new field to add to the record with the lineage, " + \
             f"e.g. h1n1pdm. If subtype is unknown, will default to {TBD_TYPE!r}")
    parser.add_argument("--annotations", metavar="TSV", 
        help="Manually curated annotations TSV file. " +
             "The TSV should have two columns, the first is the EPI ISL and " +
             "the second defines the <type>:<subtype>:<lineage>. " +
             "Lines starting with '#' are treated as comments. " +
             "Any '#' after the field value are treated as comments.")
    parser.add_argument("--annotations-field", default="gisaid_epi_isl",
        help="The record field used match against the annotations TSV")
    args = parser.parse_args()

    annotations = read_annotations_tsv(args.annotations) if args.annotations else {}

    records = load_ndjson(sys.stdin)
    modified_records = standardize_record_lineage(
        records,
        args.subtype_field,
        args.lineage_field,
        args.note_field,
        args.new_type_field,
        args.new_subtype_field,
        args.new_lineage_field,
        args.annotations_field,
        annotations)
    dump_ndjson(modified_records)
